#!/bin/bash

#Function that calculates average/median for columns
function calculate_columns () {
	#-------------Begin Column Average Calculation--------------#
	#Declare variables for calculation
	count=1
	col_sum=0
	avg=0
	median=0
	#Read the numbers of lines from file to get number of rows
	lines=$(wc -l < "$1")
	total=$(wc -w < "$1")
	let rows=$(echo "$total/$lines")
	echo "Average:	Median:"

	#Begin the loop for calculating the avg for each variable
	while (( count < rows+1 ))
	do
		col_sum=0
		cut -f "$count" $1 > output_file
		sort output_file > sorted_output
		wc -l < sorted_output > line_number
		while read -a col
		do 	
			let col_sum=$col_sum+$col
		done < sorted_output
		let rem="$col_sum%$rows"
		let dec="$rem*10"
		avg=$(echo "scale=2; $col_sum/$lines" | bc ) 
		avg=$(echo "($avg+0.5)/1" | bc )
		if [ $lines%2 = 0 ]; then 
			let half="$lines/2"
			while read val 
			do 
				let median=$(head -n "$lines" | tail -n "$half")
			done < sorted_output
		elif [ "$2" = "row" ]; then
			let half=$((1+$lines/2))
			#let new_half="$half-1"
			while read val 
			do 
				let median=$(head -n "$lines" | tail -n "$half")
			done < sorted_output
		else 
			let half="$lines/2"
			while read val 
			do 
				let median=$(head -n "$lines" | tail -n "$half")
			done < sorted_output
		fi
		echo "$avg 		$median"
		let count=count+1
	done 
	#--------------End Column Average Calculation---------------#
}

function swap () {
	awk ' {
		for (i=1; i<=NF; i++) {
			a[NR,i] = $i
		}
	}
	NF>p { p = NF }
	END {
		for(j=1; j<=p; j++) {
			str=a[1,j]
			for(i=2; i<=NR; i++) {
				str=str"\t"a[i,j];
			}
			print str > "swap_output"
		}
	} ' $1
}

function remove_files () {
	if test -e "line_number"; then
		rm line_number
	fi
	if test -e "output_file"; then
		rm output_file
	fi
	if test -e "sorted_output"; then
		rm sorted_output
	fi
	if test -e "stdin_file"; then
		rm stdin_file
	fi
	if test -e "swap_output"; then
		rm swap_output
	fi
	if test -e "stdin"; then
		rm stdin
	fi
	exit
}
#Validates input from user

#Checks first parameter is correct
if [[ $1 != -r* && $1 != -c* ]]; then
	exit 1
fi

if [ $# -eq 1 ]; then
	cat /dev/stdin > stdin
	std_file=stdin
	if [[ $1 == -r* ]]; then
		swap $std_file 
		stdin_file=swap_output
		calculate_columns $stdin_file
	elif [[ $1 == -c* ]]; then
		swap $std_file 
		stdin_file=swap_output
		swap $std_file
		calculate_columns $stdin_file
	else 
		echo "Usage: stats {-rows|-cols} [input_file]"
		exit 1
	fi
	remove_files
elif [ $# -ne 2 ]; then
	echo "Usage: stats {-rows|-cols} [input_file]"
	exit 1
fi
if [ $# -gt 1 ]; then
	file=$2
	if test -r "$file"; then
		if test -s "$file"; then
			if [[ $1 == -r* ]]; then
				swap $file 
				file=swap_output
				calculate_columns $file row
			elif [[ $1 == -c* ]]; then
				swap $file 
				file=swap_output
				swap $file
				calculate_columns $file 
			fi
			remove_files
		else 
			2>&1 echo "File is empty"
			exit 1
		fi
	else 
		2>&1 echo "I'm sorry. I can't read that file."
		exit 1
	fi
fi

trap remove_files exit