/** 
 * @file
 * @author Marshall Adrian
 * @author Joey Tomlinson
 * @author Dan Albert
 * @version 1.1
 *
<<<<<<< .mine
 * @note Robert L. Phillips III
 *
=======
 * @note Edited by Robert L. Phillips III
 *
>>>>>>> .r107
 * @section LICENSE
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 * 
 * @section DESCRIPTION
 * 
 * This program reads a voltage generated by a potentiometer and generates a PWM signal
 * to control the speed of a DC motor based on that voltage.  The speed of the motor is
 * proportional to the position of the potentiometer.
 * 
 * Target Device: ATTINY261
 * 
 * Hardware Description:
 * 
 */
 
#include <avr/io.h>
#include <stdlib.h>
#include <avr/interrupt.h>

#include "adc.h"
#include "motor_ctl.h"
#include "speedometer.h"

void setupIO(void);

 /** 
 * @brief	Main function.
 * 
 * Loops continuously, checking voltage from the potentiometer voltage devider and adjusting the motor speed accordingly.
 */
int main(void)
{
	setupIO(); //Sets data direction registers and initializes IO
	setupPWM(0b00000110, PWM_CHANNEL_B);	// Sets the clock prescaler to CK/32 (31.25KHz for a 1MHz clock)
	
	motorB(&PORTA, PA1, &PORTA, PA2);
	
	speedometer(&PORTA, PA4,
		&PORTA, PA5,
		&PORTA, PA6,
		&PORTA, PA7);
	
	// Enable ADC, start ADC, enable "Free-Running" mode, Divide clock by 4
	// Use Clock/4 for the prescaler, Don't use free running mode
	SetupADC(ADC_PRESCALER_4, FALSE);
	ADCEnable();
	
	motorB_Forward();
	
	while (1)
	{
		if (ReadADC(0) >= 138) // If potentiometer voltage is greater than 2.7V, turn motor forward with a speed proportional to the distance from 2.5V
		{
			// Set motor forward and set speed according distance from potentiomenter center position
			motorB_Forward();
			PWMB = (ADCH * 2) - 256;
		}
		else if (ReadADC(0) <= 117) // If potentiometer is less than 2.3V, turn motor in reverse with a speed proportional to the distance from 2.5V
		{
			// Set motor reverse and set speed according distance from center of potentiometer
			motorB_Reverse();
			PWMB = 255 - (ADCH * 2);
		}
		else // If potentiometer is between 2.3V and 2.7V, stop the motor.
		{
			PWMB = 0;
			motorB_Stop();
		}
		
		updateSpeedometer(PWMB, (PORTA & (1 << PA3)) ? SPEEDO_DIR_RTL : SPEEDO_DIR_LTR);
	}
}

 /** 
 * @brief	Sets data direction registers and initializes IO pins.
 *
 * Sets PA0 to input, and PA1-PA7 to output.
 * Sets PB0-PB7 to output.
 * Initializes PORTA to 0.
 * Initializes PORTB to 0.
 */
void setupIO(void) 
{
	DDRA = 0b11111110;	// Pin 0 on port a is the input for the potentiometer.
	DDRB = 0b11111111;	// All pins on port b are outputs.
	PORTA = 0b00000000;	// Initialize port a to 0.
	PORTB = 0b00000000; // Initialize port b to 0.
}
