/**
@file
@author Matthew Shuman
@author David Overgaard
@date 07/12/10
@version 2.0

@brief A local header file that defines note frequencies and function prototypes for speaker functionality.

 @section LICENSE
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 MA 02110-1301, USA.
 
 @section HARDWARE
 Target Device: ATTINY26L
 
 @section DESCRIPTION
The square wave which drives the speaker is generated by toggling an IO pin after a certine number of timer ticks.  The number of ticks needed to generate a certian frequency is calculated as follows:
	- TIMER1 Period = 1/timer_frequency = 1/62.5khz = 0.000016s
	- The period of the generated wave = timer_period*timer_ticks*2 = 0.000032*timer_ticks
	- Generated wave frequency = 1/(0.000032*timer_ticks)

 @section FUNCTION PROTOTYPES
 These are used allow other source files to use functions defined in music.c
 To use these functions in another file, #include music.h in that file.
 This will allow your file to compile using these function prototypes
 To build your final executable, you will need to compile your file and music.c
 into object files, then link these into an executable using linker software.
 This process is taken care of in the makefile for this project
 */
 
// This ifndef wrapper is called an include guard
// It prevents the header file from being included multiple times
#ifndef INCLUDED_SOUND_H
#define INCLUDED_SOUND_H

// The following #defines were calculated using the previous formula
/**
@brief G3, 196.00 Hz 
*/
#define FREQ_G_L	159
/**
@brief G3#, 207.65 Hz 
*/
#define FREQ_GS_L 	150
/**
@brief A3 , 220.00 Hz
*/
#define FREQ_A_L 	142
/**
@brief A3#, 233.08 Hz 
*/
#define FREQ_AS_L 	134	
/**
@brief B3 , 246.94 Hz
*/
#define FREQ_B_L 	126	
/**
@brief C4 , 261.63 Hz (Middle C)
*/
#define FREQ_C 		119 
/**
@brief C4#, 277.18 Hz 
*/
#define FREQ_CS 	113	
/**
@brief D4, 293.66 Hz 
*/
#define FREQ_D 		106 
/**
@brief D4#, 311.13 Hz 
*/
#define FREQ_DS 	100	
/**
@brief E4 , 329.63 Hz 
*/
#define FREQ_E 		95 	
/**
@brief F4 , 349.23 Hz 
*/
#define FREQ_F 		89	
/**
@brief F4#, 369.99 Hz
*/
#define FREQ_FS 	84	 
/**
@brief G4 , 392.00 Hz 
*/
#define FREQ_G 		80	
/**
@brief G4#, 415.30 Hz
*/
#define FREQ_GS 	75	 
/**
@brief A4 , 440.00 Hz (Standard tuning note) 
*/
#define FREQ_A 		71	
/**
@briefA4#, 466.16 Hz 
*/
#define FREQ_AS 	67	
/**
@brief B4 , 493.88 Hz
*/
#define FREQ_B 		63	 
/**
@brief C5 , 523.25 Hz 
*/
#define FREQ_C_H 	60	
/**
@brief C5#, 523.25 Hz 
*/
#define FREQ_CS_H 	56	
/**
@brief D5, 587.33 Hz 
*/
#define FREQ_D_H 	53	
/**
@brief D5#, 622.25 Hz 
*/
#define FREQ_DS_H 	50	
/**
@brief E5, 659.25 Hz 
*/
#define FREQ_E_H 	47	
/**
@brief F5, 698.46 Hz 
*/
#define FREQ_F_H 	44	
/**
@brief F5#, 739.99 Hz  
*/
#define FREQ_FS_H 	42	
/**
@brief G5, 783.99 Hz 
*/
#define FREQ_G_H 	39	
/**
@brief G5#, 830.61 Hz 
*/
#define FREQ_GS_H 	37	
/**
@brief A5, 880.00 Hz 
*/
#define FREQ_A_H 	35	
/**
@brief A5#, 932.33 Hz 
*/
#define FREQ_AS_H 	33	
/**
@brief B5, 987.77 Hz 
*/
#define FREQ_B_H 	31	
/**
@brief C6 , 1046.5 Hz
*/
#define FREQ_C_HH 	29	 
/**
@brief C6#, 1108.7 Hz
*/
#define FREQ_CS_HH 	28	
/**
@brief D6, 1174.7 Hz 
*/
#define FREQ_D_HH 	26	
/**
@brief D6#, 1244.5 Hz 
*/
#define FREQ_DS_HH 	25	

#include <avr/io.h>

/**
@return void
*/
void setupSpeaker(unsigned char* spkrPort, unsigned char spkrPin);

/**
@return void
*/
void setFrequency(unsigned char);

/**
@return void
*/
void speakerOn();

/**
@return void
*/
void disableSpeaker();

void QuarterNote(unsigned char note);
void QuarterRest(void);
void EighthNote(unsigned char note);
void EighthRest(void);

void MeasureOne(void);
void MeasureTwo(void);
void MeasureThree(void);
void MeasureFour(void);
void MeasureFive(void);
void MeasureSix(void);
void MeasureSeven(void);
void MeasureEight(void);
void MeasureNine(void);
void MeasureTen(void);
void MeasureEleven(void);
void MeasureTwelve(void);
void MeasureThirteen(void);
void MeasureFourteen(void);
void MeasureFifteen(void);
void MeasureSixteen(void);
void MeasureEighteen(void);
void MeasureNineteen(void);
void MeasureTwenty(void);

void MeasureTwentyOne(void);

/**
 * ISR is a predefined macro defined in interrupt.h
 * It runs every time the specified hardware interrupt is triggered.
 * Availible interrupt names are listed here: http://www.nongnu.org/avr-libc/user-manual/group__avr__interrupts.html
 *
 * In this case we are using SIG_OUTPUT_COMPARE1A, which is triggered whenever TCNT1 (the TIMER1 counting register)
 * is equal to OCR1A.  We use this to toggle the speaker line at regular intervals, generating a square wave.
 * 
 * @param SIG_OUTPUT_COMPARE1A specifies that we are handling the COMPARE1A interupt
 * 
 */
/*ISR(TIMER1_CMPA_vect) {
	PORTA ^= 0b00000001; // TOGGLE_SPKR()
	TCNT1  = 0; // reset TIMER1 to 0
}
*/
#endif // INCLUDED_SOUND_H
