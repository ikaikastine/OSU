Pseudocode for three methods:
	
	methodOne(suffix[0,..., n], prefix[0,..., m])
		bestSuffix = n
		bestPrefix = 0
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				best = abs(suffix[bestSuffix] + prefix[bestPrefix])
				curr = abs(suffix[i] + prefix[j])
				if curr < best
					bestPrefix = i
					bestSuffix = j
			}
		}
		return bestSuffix, bestPrefix 

	methodTwo(suffix[0,...,n], prefix[0,...,m])
		bestSuffix = n
		bestPrefix = 0
		sortedSuffix = sort(suffix)
		sortedPrefix = sort(prefix)
		minSum = INT_MAX
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				sum = sortedSuffix[i] + sortedPrefix[j]
				if (abs(sum) < abs(minSum)) {
					minSum = sum
					minSuffix = i
					minPrefix = j
				}
			}
		}

	methodThree(suffix[0,...,n], prefix[0,...m])
		bestSuffix = n
		bestPrefix = 0
		for (int i = 0; i < m; i++) {
			prefix[i] = -abs(prefix[i])
		}
		list = suffix + prefix
		sortedList = sort(list)
		//Set initial best value
		bestVal = sortedList[0]
		for (int j = 0; j < sizeof(sortedList); j++) {
			(abs(sortedList[j]) - abs(sortedList[j+1])) = curBest
			if curBest < bestVal {
				bestVal = curBest
				bestSuffix = sortedList[j]
				bestPrefix = sortedList[j+1]
			}
		}
		return bestVal, bestSuffix, bestPrefix

Pseudocode for divide & conquer algorithm
