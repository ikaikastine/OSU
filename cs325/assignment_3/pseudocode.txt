Pseudocode for three methods:
	
	methodOne(suffix[0,..., n], prefix[0,..., m])
		bestSuffix = n
		bestPrefix = 0
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				best = abs(suffix[bestSuffix] + prefix[bestPrefix])
				curr = abs(suffix[i] + prefix[j])
				if curr < best
					bestPrefix = i
					bestSuffix = j
			}
		}
		return bestSuffix, bestPrefix 

	methodTwo(suffix[0,...,n], prefix[0,...,m])
		bestSuffix = n
		bestPrefix = 0
		sortedSuffix = sort(suffix)
		sortedPrefix = sort(prefix)
		minSum = INT_MAX
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				sum = sortedSuffix[i] + sortedPrefix[j]
				if (abs(sum) < abs(minSum)) {
					minSum = sum
					minSuffix = i
					minPrefix = j
				}
			}
		}

	methodThree(suffix[0,...,n], prefix[0,...m])
		bestSuffix = n
		bestPrefix = 0
		for (int i = 0; i < m; i++) {
			prefix[i] = -abs(prefix[i])
		}
		list = suffix + prefix
		sortedList = sort(list)
		//Set initial best value
		bestVal = sortedList[0]
		for (int j = 0; j < sizeof(sortedList); j++) {
			(abs(sortedList[j]) - abs(sortedList[j+1])) = curBest
			if curBest < bestVal {
				bestVal = curBest
				bestSuffix = sortedList[j]
				bestPrefix = sortedList[j+1]
			}
		}
		return bestVal, bestSuffix, bestPrefix

Pseudocode for divide & conquer algorithm

	int recurse(array, size) {
		if size == 1
			return array[0]
		else if size == 2 
			return lesserOf(array[0], array[1])
		else if (size == 3 || size == 4)
			return enumerate(array,size)
		else 
			split array
			return lesserOf(array1, array2)
	}

	int lesserOf(int a, int b) {
		if (a < b) {
			return a
		} else {
			return b
		}
	}

	int enumerate(array, size) {
		smallestSum = sumarray1[0] + sumarray2[0]
		for (int i = 1; i < array1size; i++) {
			for (int j = 0; j < array2size; j++) {
				tempsum = sumarray1[i] + sumarray2[j]
				if (abs(tempsum) < abs(smallestsum)) {
					smallestsum = tempsum
				}
			}
		}
		return smallestsum
	}