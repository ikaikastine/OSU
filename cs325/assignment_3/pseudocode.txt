Pseudocode for three methods:
	
	methodOne(suffix[0,..., n], prefix[0,..., m])
		sumOfSuffix(suffix)
		sumOfPrefix(prefix)
		bestSuffix = n
		bestPrefix = 0
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				best = abs(suffix[bestSuffix] + prefix[bestPrefix])
				curr = abs(suffix[i] + prefix[j])
				if curr < best
					bestPrefix = i
					bestSuffix = j
			}
		}
		return bestSuffix, bestPrefix 

	methodTwo(suffix[0,...,n], prefix[0,...,m])
		sumOfSuffix(suffix)
		sumOfPrefix(prefix)
		bestSuffix = n
		bestPrefix = 0
		sortedSuffix = sort(suffix)
		sortedPrefix = sort(prefix)
		minSum = INT_MAX
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				sum = sortedSuffix[i] + sortedPrefix[j]
				if (abs(sum) < abs(minSum)) {
					minSum = sum
					minSuffix = i
					minPrefix = j
				}
			}
		}

	methodThree(suffix[0,...,n], prefix[0,...m])
		sumOfSuffix(suffix)
		sumOfPrefix(prefix)
		bestSuffix = n
		bestPrefix = 0
		for (int i = 0; i < m; i++) {
			prefix[i] = -abs(prefix[i])
		}
		list = suffix + prefix
		sortedList = sort(list)
		//Set initial best value
		bestVal = sortedList[0]
		for (int j = 0; j < sizeof(sortedList); j++) {
			(abs(sortedList[j]) - abs(sortedList[j+1])) = curBest
			if curBest < bestVal {
				bestVal = curBest
				bestSuffix = sortedList[j]
				bestPrefix = sortedList[j+1]
			}
		}
		return bestVal, bestSuffix, bestPrefix

Pseudocode for divide & conquer algorithm

	sumOfSuffix(suffix)
	sumOfPrefix(prefix)

	def computer(suffix, prefix):
		for i in range(0, len(prefix)):
			#take negative of all values in prefix
			prefix[i] = -(prefix[i]))
		for i in range(0, len(combinedArray)):
        for j in range (i+1, len(combinedArray)):
            tempSum = arrSum
            initVal = combinedArray[j]
            secondVal = combinedArray[i]

            if secondVal < 0:
                if initVal > 0:
                   arrSum = abs(initVal) - (secondVal) 
                else:
                    arrSum = abs(initVal) - abs(secondVal)
            else:
                arrSum = abs(initVal) - abs(secondVal)
            if  abs(arrSum) < minSum:
                minSum = abs(arrSum)
                start = i
                startVal = secondVal
                finish = j
                finishVal = initVal
            else:
                arrSum = tempSum
            if smallestVal < minSum:
                minSum = smallestVal
